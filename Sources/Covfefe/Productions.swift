//
//  Productions.swift
//  Covfefe
//
//  Created by Palle Klewitz on 07.08.17.
//  Copyright (c) 2017 Palle Klewitz
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.

import Foundation

/// A production describing what symbols can be generated starting from a given non-terminal pattern
public struct Production: Codable {
	
	/// Starting pattern
	public let pattern: NonTerminal
	
	/// Symbols produced from the starting pattern
	public let production: [Symbol]
	
	/// Chain of non-terminals which have been eliminated during normalization
	public let nonTerminalChain: [NonTerminal]?
	
	/// Creates a new production
	///
	/// - Parameters:
	///   - pattern: Starting pattern
	///   - production: Generated sequence of symbols
	public init(pattern: NonTerminal, production: ProductionString) {
		self.pattern = pattern
		self.production = production.characters
		self.nonTerminalChain = nil
	}
	
	/// Creates a new production
	///
	/// - Parameters:
	///   - pattern: Starting pattern
	///   - production: Generated sequence of symbols
	///   - chain: Non-terminals which have been filtered out during normalization
	public init(pattern: NonTerminal, production: [Symbol], chain: [NonTerminal]? = nil) {
		self.pattern = pattern
		self.production = production
		self.nonTerminalChain = chain
	}
	
	/// A production is linear if the generated symbol sequence contains zero or one non-terminal
	public var isLinear: Bool {
		return self.production.filter { symbol -> Bool in
			if case .nonTerminal(_) = symbol {
				return true
			} else {
				return false
			}
		}.count <= 1
	}
	
	/// A production is right linear if it only generates terminal symbols or if it is linear and the non-terminal is in the last position
	public var isRightLinear: Bool {
		guard isLinear else {
			return false
		}
		if let index = self.production.index(where: { symbol -> Bool in
			if case .nonTerminal(_) = symbol {
				return true
			} else {
				return false
			}
		}) {
			return index == self.production.count - 1
		}
		return true
	}
	
	/// A production is right linear if it only generates terminal symbols or if it is linear and the non-terminal is in the first position
	public var isLeftLinear: Bool {
		guard isLinear else {
			return false
		}
		if let index = self.production.index(where: { symbol -> Bool in
			if case .nonTerminal(_) = symbol {
				return true
			} else {
				return false
			}
		}) {
			return index == 0
		}
		return true
	}
	
	/// A production is final if it only generates terminal symbols
	public var isFinal: Bool {
		return self.production.allMatch { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		}
	}
	
	/// A production is in Chomsky normal form if it generates exactly 2 non-terminals
	/// exclusive or one or zero terminal symbols
	public var isInChomskyNormalForm: Bool {
		if isFinal {
			return production.count == 1
		}
		return self.production.allMatch { symbol -> Bool in
			if case .nonTerminal(_) = symbol {
				return true
			} else {
				return false
			}
		} && self.production.count == 2
	}
	
	var generatedString: String {
		return generatedTerminals.map(\.value).joined()
	}
	
	/// Sequence of terminals generated by this production
	public var generatedTerminals: [Terminal] {
		return production.flatMap{ symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol  else {
				return nil
			}
			return terminal
		}
	}
	
	var terminalPrefix: [Terminal] {
		let prefix = production.prefix(while: { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		})
		return prefix.flatMap { symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol else {
				return nil
			}
			return terminal
		}
	}
	
	var terminalSuffix: [Terminal] {
		let suffix = production.reversed().prefix(while: { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		}).reversed()
		
		return suffix.flatMap { symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol else {
				return nil
			}
			return terminal
		}
	}
	
	var prefixString: String {
		return terminalPrefix.map(\.value).joined()
	}
	
	var suffixString: String {
		return terminalSuffix.map(\.value).joined()
	}
	
	/// Returns wether the production can be used to generate parts of the given string
	///
	/// - Parameter word: String to check
	/// - Returns: A boolean value indicating whether the string can be generated in part by this production
	public func canGenerateSubstring(of word: String) -> Bool {
		if isRightLinear {
			return word.hasPrefix(terminalPrefix)
		} else if isLeftLinear {
			return word.hasPrefix(terminalSuffix)
		} else if isLinear {
			return word.hasPrefix(terminalPrefix) && word.hasSuffix(terminalSuffix)
		} else {
			fatalError("Cannot check if non-linear production generates substring.")
		}
	}
	
	/// Returns true if the production is final and the generated string is equal to the given word
	///
	/// - Parameter word: Word to check
	/// - Returns: A boolean value indicating whether the given word can be fully generated by the production
	public func canFullyGenerate(word: String) -> Bool {
		guard isFinal else {
			return false
		}
		return generatedString == word
	}
	
	/// Removes prefixes and suffixes of the given word which can be generated by the terminal prefix and suffix of this production
	///
	/// - Parameter word: Word to trim
	/// - Returns: Trimmed word
	public func removingGeneratedSubstring(from word: String) -> String {
		guard canGenerateSubstring(of: word) else {
			return word
		}
		
		if isRightLinear, let range = word.rangeOfPrefix(terminalPrefix) {
			var mutableWord = word
			mutableWord.removeSubrange(range)
			return mutableWord
		} else if isLeftLinear, let range = word.rangeOfSuffix(terminalSuffix) {
			var mutableWord = word
			mutableWord.removeSubrange(range)
			return mutableWord
		} else if isLinear {
			var mutableWord = word
			
			guard let prefixRange = word.rangeOfPrefix(terminalPrefix),
				let suffixRange = word.rangeOfSuffix(terminalSuffix) else {
					return word
			}
			
			mutableWord.removeSubrange(suffixRange)
			mutableWord.removeSubrange(prefixRange)
			return mutableWord
		} else {
			fatalError("Cannot remove generated substring from non-left-linear or -right-linear production.")
		}
	}
	
	var generatedNonTerminals: [NonTerminal] {
		return production.flatMap { symbol -> NonTerminal? in
			guard case .nonTerminal(let nonTerminal) = symbol else {
				return nil
			}
			return nonTerminal
		}
	}
}

extension Production: Hashable {
	public var hashValue: Int {
		return pattern.hashValue ^ production.map(\.hashValue).reduce(0, ^)
	}
	
	public static func ==(lhs: Production, rhs: Production) -> Bool {
		return lhs.pattern == rhs.pattern && lhs.production == rhs.production
	}
}

extension Production: CustomStringConvertible {
	public var description: String {
		return "\(pattern.name) --> \(production.map{$0.description}.joined(separator: " "))"
	}
}

extension Production: CustomDebugStringConvertible {
	public var debugDescription: String {
		return """
		production {
			pattern: \(self.pattern)
			produces: \(self.production.map(\.description))
			chain: \(self.nonTerminalChain?.map(\.description).joined(separator: ", ") ?? "empty")
		}
		"""
	}
}

precedencegroup ProductionPrecedence {
	associativity: left
	lowerThan: AdditionPrecedence
}

infix operator --> : ProductionPrecedence

/// Generates a production from a given non-terminal and produced sequence of symbols
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Produced string of symbols
/// - Returns: Production with the given pattern and generated result
public func --> (lhs: NonTerminal, rhs: ProductionString) -> Production {
	return Production(pattern: lhs, production: rhs)
}

/// Generates a set of productions from a given non-terminal and produced result
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Collection of possible produced strings of symbols
/// - Returns: Productions with the given pattern and generated results
public func --> (lhs: NonTerminal, rhs: ProductionResult) -> [Production] {
	return rhs.elements.map { producedString in
		return Production(pattern: lhs, production: producedString)
	}
}

/// Generates a production from the given non-terminal to the given symbol
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Produced symbol
/// - Returns: Production with the given pattern generating the given symbol
public func --> (lhs: NonTerminal, rhs: Symbol) -> Production {
	return Production(pattern: lhs, production: [rhs])
}


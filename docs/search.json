{"Structs/DefaultTokenizer.html#/s:7Covfefe16DefaultTokenizerVAcA7GrammarV7grammar_tcfc":{"name":"init(grammar:)","abstract":"<p>Creates a new tokenizer using a Chomsky normalized grammar</p>","parent_name":"DefaultTokenizer"},"Structs/DefaultTokenizer.html#/s:7Covfefe9TokenizerP8tokenizeSaySayAA8TerminalV8terminal_s5RangeVySS5IndexVG5rangetGGSSKF":{"name":"tokenize(_:)","parent_name":"DefaultTokenizer"},"Structs/Terminal.html#/s:7Covfefe8TerminalV5valueSSv":{"name":"value","abstract":"<p>Value of the terminal</p>","parent_name":"Terminal"},"Structs/Terminal.html#/s:7Covfefe8TerminalV19isRegularExpressionSbv":{"name":"isRegularExpression","abstract":"<p>Indicates whether the value of the non-terminal is a regular expression</p>","parent_name":"Terminal"},"Structs/Terminal.html#/s:7Covfefe8TerminalVACSS5value_Sb19isRegularExpressiontKcfc":{"name":"init(value:isRegularExpression:)","abstract":"<p>Creates a new terminal value which can occurr in a string</p>","parent_name":"Terminal"},"Structs/Terminal.html#/s:s26ExpressibleByStringLiteralPx0cD4TypeQz06stringD0_tcfc":{"name":"init(stringLiteral:)","parent_name":"Terminal"},"Structs/Terminal.html#/s:s8HashableP9hashValueSiv":{"name":"hashValue","parent_name":"Terminal"},"Structs/Terminal.html#/s:s9EquatableP2eeoiSbx_xtFZ":{"name":"==(_:_:)","parent_name":"Terminal"},"Structs/Terminal.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"Terminal"},"Structs/NonTerminal.html#/s:7Covfefe11NonTerminalV4nameSSv":{"name":"name","abstract":"<p>Name of the non-terminal</p>","parent_name":"NonTerminal"},"Structs/NonTerminal.html#/s:7Covfefe11NonTerminalVACSS4name_tcfc":{"name":"init(name:)","abstract":"<p>Creates a new non-terminal symbol with a given name</p>","parent_name":"NonTerminal"},"Structs/NonTerminal.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"NonTerminal"},"Structs/NonTerminal.html#/s:s26ExpressibleByStringLiteralPx0cD4TypeQz06stringD0_tcfc":{"name":"init(stringLiteral:)","parent_name":"NonTerminal"},"Structs/NonTerminal.html#/s:s8HashableP9hashValueSiv":{"name":"hashValue","parent_name":"NonTerminal"},"Structs/NonTerminal.html#/s:s9EquatableP2eeoiSbx_xtFZ":{"name":"==(_:_:)","parent_name":"NonTerminal"},"Structs/Production.html#/s:7Covfefe10ProductionV7patternAA11NonTerminalVv":{"name":"pattern","abstract":"<p>Starting pattern</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionV10productionSayAA6SymbolOGv":{"name":"production","abstract":"<p>Symbols produced from the starting pattern</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionV16nonTerminalChainSayAA03NonD0VGSgv":{"name":"nonTerminalChain","abstract":"<p>Chain of non-terminals which have been eliminated during normalization</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionVAcA11NonTerminalV7pattern_AA0B6StringV10productiontcfc":{"name":"init(pattern:production:)","abstract":"<p>Creates a new production</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionVAcA11NonTerminalV7pattern_SayAA6SymbolOG10productionSayAEGSg5chaintcfc":{"name":"init(pattern:production:chain:)","abstract":"<p>Creates a new production</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionV7isFinalSbv":{"name":"isFinal","abstract":"<p>A production is final if it only generates terminal symbols</p>","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionV21isInChomskyNormalFormSbv":{"name":"isInChomskyNormalForm","abstract":"<p>A production is in Chomsky normal form if it generates exactly 2 non-terminals","parent_name":"Production"},"Structs/Production.html#/s:7Covfefe10ProductionV18generatedTerminalsSayAA8TerminalVGv":{"name":"generatedTerminals","abstract":"<p>Sequence of terminals generated by this production</p>","parent_name":"Production"},"Structs/Production.html#/s:s8HashableP9hashValueSiv":{"name":"hashValue","parent_name":"Production"},"Structs/Production.html#/s:s9EquatableP2eeoiSbx_xtFZ":{"name":"==(_:_:)","parent_name":"Production"},"Structs/Production.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"Production"},"Structs/Production.html#/s:s28CustomDebugStringConvertibleP16debugDescriptionSSv":{"name":"debugDescription","parent_name":"Production"},"Structs/SyntaxError/Reason.html#/s:7Covfefe11SyntaxErrorV6ReasonO15emptyNotAllowedA2EmF":{"name":"emptyNotAllowed","abstract":"<p>An empty string was provided but the grammar does not allow empty productions</p>","parent_name":"Reason"},"Structs/SyntaxError/Reason.html#/s:7Covfefe11SyntaxErrorV6ReasonO12unknownTokenA2EmF":{"name":"unknownToken","abstract":"<p>The tokenization could not be completed because no matching token was found</p>","parent_name":"Reason"},"Structs/SyntaxError/Reason.html#/s:7Covfefe11SyntaxErrorV6ReasonO16unmatchedPatternA2EmF":{"name":"unmatchedPattern","abstract":"<p>A pattern was found which could not be merged</p>","parent_name":"Reason"},"Structs/SyntaxError/Reason.html#/s:7Covfefe11SyntaxErrorV6ReasonO15unexpectedTokenA2EmF":{"name":"unexpectedToken","abstract":"<p>A token was found that could not be parsed</p>","parent_name":"Reason"},"Structs/SyntaxError/Reason.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"Reason"},"Structs/SyntaxError/Reason.html":{"name":"Reason","abstract":"<p>The reason for the syntax error</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:7Covfefe11SyntaxErrorV5ranges5RangeVySS5IndexVGv":{"name":"range","abstract":"<p>Range in which the error occurred</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:7Covfefe11SyntaxErrorV6reasonAC6ReasonOv":{"name":"reason","abstract":"<p>Reason for the error</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:7Covfefe11SyntaxErrorV7contextSayAA11NonTerminalVGv":{"name":"context","abstract":"<p>The context around the error</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:7Covfefe11SyntaxErrorV6stringSSv":{"name":"string","abstract":"<p>The string for which the parsing was unsuccessful</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:7Covfefe11SyntaxErrorVACs5RangeVySS5IndexVG5range_SS2inAC6ReasonO6reasonSayAA11NonTerminalVG7contexttcfc":{"name":"init(range:in:reason:context:)","abstract":"<p>Creates a new syntax error with a given range and reason</p>","parent_name":"SyntaxError"},"Structs/SyntaxError.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"SyntaxError"},"Structs/EarleyParser.html#/s:7Covfefe12EarleyParserV7grammarAA7GrammarVv":{"name":"grammar","abstract":"<p>The grammar recognized by the parser</p>","parent_name":"EarleyParser"},"Structs/EarleyParser.html#/s:7Covfefe12EarleyParserVAcA7GrammarV7grammar_tcfc":{"name":"init(grammar:)","abstract":"<p>Generates an earley parser for the given grammar.</p>","parent_name":"EarleyParser"},"Structs/EarleyParser.html#/s:7Covfefe6ParserP10syntaxTreeAA06SyntaxD0OyAA11NonTerminalVs5RangeVySS5IndexVGGSS3for_tKF":{"name":"syntaxTree(for:)","parent_name":"EarleyParser"},"Structs/EarleyParser.html#/s:7Covfefe22AmbiguousGrammarParserP14allSyntaxTreesSayAA0F4TreeOyAA11NonTerminalVs5RangeVySS5IndexVGGGSS3for_tKF":{"name":"allSyntaxTrees(for:)","parent_name":"EarleyParser"},"Structs/ProductionResult.html#/s:7Covfefe16ProductionResultV8elementsSayAA0B6StringVGv":{"name":"elements","abstract":"<p>The possible production strings of this result</p>","parent_name":"ProductionResult"},"Structs/ProductionResult.html#/s:7Covfefe16ProductionResultVACSayAA0B6StringVG7symbols_tcfc":{"name":"init(symbols:)","abstract":"<p>Creates a new production result.</p>","parent_name":"ProductionResult"},"Structs/ProductionResult.html#/s:s25ExpressibleByArrayLiteralPxSay0cD7ElementQzG05arrayD0d_tcfc":{"name":"init(arrayLiteral:)","parent_name":"ProductionResult"},"Structs/ProductionResult.html#/s:7Covfefe16ProductionResultVAcA9SymbolSetVcfc":{"name":"init(_:)","abstract":"<p>Creates a new production result from a symbol set where every symbol generates a different result independent of other symbols</p>","parent_name":"ProductionResult"},"Structs/NonTerminalString.html#/s:7Covfefe17NonTerminalStringV10charactersSayAA0bC0VGv":{"name":"characters","abstract":"<p>The non-terminal characters of this string</p>","parent_name":"NonTerminalString"},"Structs/NonTerminalString.html#/s:s8HashableP9hashValueSiv":{"name":"hashValue","parent_name":"NonTerminalString"},"Structs/NonTerminalString.html#/s:s9EquatableP2eeoiSbx_xtFZ":{"name":"==(_:_:)","parent_name":"NonTerminalString"},"Structs/ProductionString.html#/s:7Covfefe16ProductionStringV10charactersSayAA6SymbolOGv":{"name":"characters","abstract":"<p>Symbols of this production string</p>","parent_name":"ProductionString"},"Structs/ProductionString.html#/s:7Covfefe16ProductionStringVACSayAA6SymbolOGcfc":{"name":"init(_:)","abstract":"<p>Creates a new production string</p>","parent_name":"ProductionString"},"Structs/ProductionString.html#/s:s25ExpressibleByArrayLiteralPxSay0cD7ElementQzG05arrayD0d_tcfc":{"name":"init(arrayLiteral:)","parent_name":"ProductionString"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV10whitespaceAA16ProductionResultVvZ":{"name":"whitespace","abstract":"<p>Whitespace characters (space, tab and line break)</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV9lowercaseAA16ProductionResultVvZ":{"name":"lowercase","abstract":"<p>Lower case letters a to z</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV9uppercaseAA16ProductionResultVvZ":{"name":"uppercase","abstract":"<p>Upper case letters A to Z</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV7numbersAA16ProductionResultVvZ":{"name":"numbers","abstract":"<p>Decimal digits 0 to 9</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV7lettersAA16ProductionResultVvZ":{"name":"letters","abstract":"<p>Lower and upper case letters a to z and A to Z</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV13alphanumericsAA16ProductionResultVvZ":{"name":"alphanumerics","abstract":"<p>Alphanumeric characters (Letters and numbers)</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetV7symbolsSayAA0B0OGv":{"name":"symbols","abstract":"<p>Symbols contained in this symbol set</p>","parent_name":"SymbolSet"},"Structs/SymbolSet.html#/s:7Covfefe9SymbolSetVACxcs8SequenceRzAA0B0O7ElementRtzlufc":{"name":"init(_:)","abstract":"<p>Creates a new symbol set given a sequence of symbols</p>","parent_name":"SymbolSet"},"Structs/CYKParser.html#/s:7Covfefe9CYKParserV7grammarAA7GrammarVv":{"name":"grammar","abstract":"<p>The grammar which the parser recognizes</p>","parent_name":"CYKParser"},"Structs/CYKParser.html#/s:7Covfefe9CYKParserVAcA7GrammarV7grammar_tcfc":{"name":"init(grammar:)","abstract":"<p>Initializes a CYK parser which recognizes the given grammar.</p>","parent_name":"CYKParser"},"Structs/CYKParser.html#/s:7Covfefe6ParserP10syntaxTreeAA06SyntaxD0OyAA11NonTerminalVs5RangeVySS5IndexVGGSS3for_tKF":{"name":"syntaxTree(for:)","parent_name":"CYKParser"},"Structs/CYKParser.html#/s:7Covfefe22AmbiguousGrammarParserP14allSyntaxTreesSayAA0F4TreeOyAA11NonTerminalVs5RangeVySS5IndexVGGGSS3for_tKF":{"name":"allSyntaxTrees(for:)","parent_name":"CYKParser"},"Structs/Grammar.html#/s:7Covfefe7GrammarV11productionsSayAA10ProductionVGv":{"name":"productions","abstract":"<p>Productions for generating words of the language generated by this grammar</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV5startAA11NonTerminalVv":{"name":"start","abstract":"<p>Root non-terminal</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarVACSayAA10ProductionVG11productions_AA11NonTerminalV5starttcfc":{"name":"init(productions:start:)","abstract":"<p>Creates a new grammar with a given set of productions and a start non-terminal</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarVACSS9bnfString_SS5starttKcfc":{"name":"init(bnfString:start:)","abstract":"<p>Creates a new grammar from a specification in Backus-Naur Form (BNF)</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV21isInChomskyNormalFormSbv":{"name":"isInChomskyNormalForm","abstract":"<p>Returns true, if the grammar is in chomsky normal form.</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV23unreachableNonTerminalss3SetVyAA0D8TerminalVGv":{"name":"unreachableNonTerminals","abstract":"<p>Non-terminals which cannot be reached from the start non-terminal</p>","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV24unterminatedNonTerminalss3SetVyAA0D8TerminalVGv":{"name":"unterminatedNonTerminals","abstract":"<p>Nonterminals which can never produce a sequence of terminals","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV17chomskyNormalizedACyF":{"name":"chomskyNormalized()","abstract":"<p>Generates a context free grammar equal to the current grammar which is in Chomsky Normal Form.","parent_name":"Grammar"},"Structs/Grammar.html#/s:7Covfefe7GrammarV06prefixB0ACyF":{"name":"prefixGrammar()","abstract":"<p>Generates a grammar which recognizes all prefixes of the original grammar.</p>","parent_name":"Grammar"},"Structs/Grammar.html":{"name":"Grammar","abstract":"<p>A context free or regular grammar"},"Structs/CYKParser.html":{"name":"CYKParser","abstract":"<p>A parser based on the CYK algorithm.</p>"},"Structs/SymbolSet.html":{"name":"SymbolSet","abstract":"<p>A set of terminal or non-terminal symbols</p>"},"Structs/ProductionString.html":{"name":"ProductionString","abstract":"<p>A string of symbols which can be used in a production of a grammar</p>"},"Structs/NonTerminalString.html":{"name":"NonTerminalString","abstract":"<p>A string of non-terminal symbols</p>"},"Structs/ProductionResult.html":{"name":"ProductionResult","abstract":"<p>A production result contains multiple possible production strings"},"Structs/EarleyParser.html":{"name":"EarleyParser","abstract":"<p>A parser generator implementation that internally uses"},"Structs/SyntaxError.html":{"name":"SyntaxError","abstract":"<p>A syntax error which was generated during parsing or tokenization</p>"},"Structs/Production.html":{"name":"Production","abstract":"<p>A production describing what symbols can be generated starting from a given non-terminal pattern</p>"},"Structs/NonTerminal.html":{"name":"NonTerminal","abstract":"<p>A non-terminal symbol, which cannot occurr in a word recognized by a parser</p>"},"Structs/Terminal.html":{"name":"Terminal","abstract":"<p>A terminal symbol which can occur in a string recognized by a parser and which cannot be"},"Structs/DefaultTokenizer.html":{"name":"DefaultTokenizer","abstract":"<p>A simple tokenizer which uses a all terminals in a grammar for tokenization.</p>"},"Protocols/Tokenizer.html#/s:7Covfefe9TokenizerP8tokenizeSaySayAA8TerminalV8terminal_s5RangeVySS5IndexVG5rangetGGSSKF":{"name":"tokenize(_:)","abstract":"<p>Tokenizes the given word and returns a sequence of possible tokens for each unit of the string</p>","parent_name":"Tokenizer"},"Protocols/AmbiguousGrammarParser.html#/s:7Covfefe22AmbiguousGrammarParserP14allSyntaxTreesSayAA0F4TreeOyAA11NonTerminalVs5RangeVySS5IndexVGGGSS3for_tKF":{"name":"allSyntaxTrees(for:)","abstract":"<p>Generates all syntax trees explaining how a word can be derived from a grammar.</p>","parent_name":"AmbiguousGrammarParser"},"Protocols/Parser.html#/s:7Covfefe6ParserP10syntaxTreeAA06SyntaxD0OyAA11NonTerminalVs5RangeVySS5IndexVGGSS3for_tKF":{"name":"syntaxTree(for:)","abstract":"<p>Creates a syntax tree which explains how a word was derived from a grammar</p>","parent_name":"Parser"},"Protocols/Parser.html#/s:7Covfefe6ParserPAAE10recognizesSbSSF":{"name":"recognizes(_:)","abstract":"<p>Returns true if the recognized language contains the given tokenization.</p>","parent_name":"Parser"},"Protocols/Parser.html":{"name":"Parser","abstract":"<p>A parser which can check if a word is in a language"},"Protocols/AmbiguousGrammarParser.html":{"name":"AmbiguousGrammarParser","abstract":"<p>A parser that can parse ambiguous grammars and retrieve every possible syntax tree</p>"},"Protocols/Tokenizer.html":{"name":"Tokenizer","abstract":"<p>A string tokenizer which tokenizes a string based on final productions of a context free grammar.</p>"},"Functions/==(_:_:).html#/s:7Covfefe2eeoiSbAA10SyntaxTreeOyxq_G_AEts9EquatableRzsAFR_r0_lF7ElementL_xmfp":{"name":"Element","parent_name":"==(_:_:)"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionStringVAD_ADtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates two production strings</p>"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionStringVAD_AA6SymbolOtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates a production string and a symbol</p>"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionStringVAA6SymbolO_ADtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates a production string and a symbol</p>"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionStringVAA6SymbolO_AFtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates two production symbols into a production string</p>"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionResultVAD_ADtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates every possible production of the first production result with"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionResultVAD_AA0C6StringVtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates every production string of the production result with the given production string</p>"},"Functions.html#/s:7Covfefe3lpgoiAA16ProductionResultVAA0C6StringV_ADtF":{"name":"<+>(_:_:)","abstract":"<p>Concatenates the given production string with every production string of the production result</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAD_ADtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing every production string of the given production results</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAD_AA0C6StringVtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing every production of the left production result and the production string</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA0C6StringV_ADtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing the left production string and every production of the right production string</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA0C6StringV_AFtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing the left and right production string</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA0C6StringV_AA6SymbolOtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing the left production string and the right symbol</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA6SymbolO_AA0C6StringVtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing the left symbol and the right production string</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAD_AA6SymbolOtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result by appending the right symbol to the left production result</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA6SymbolO_ADtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result by appending the left symbol to the right production result</p>"},"Functions.html#/s:7Covfefe3logoiAA16ProductionResultVAA6SymbolO_AFtF":{"name":"<|>(_:_:)","abstract":"<p>Generates a production result containing the left and right symbol</p>"},"Functions.html#/s:7Covfefe3ssgoiAA10ProductionVAA11NonTerminalV_AA0C6StringVtF":{"name":"-->(_:_:)","abstract":"<p>Generates a production from a given non-terminal and produced sequence of symbols</p>"},"Functions.html#/s:7Covfefe3ssgoiSayAA10ProductionVGAA11NonTerminalV_AA0C6ResultVtF":{"name":"-->(_:_:)","abstract":"<p>Generates a set of productions from a given non-terminal and produced result</p>"},"Functions.html#/s:7Covfefe3ssgoiAA10ProductionVAA11NonTerminalV_AA6SymbolOtF":{"name":"-->(_:_:)","abstract":"<p>Generates a production from the given non-terminal to the given symbol</p>"},"Functions.html#/s:7Covfefe1tAA6SymbolOSSF":{"name":"t(_:)","abstract":"<p>Creates a new non-regular terminal symbol</p>"},"Functions.html#/s:7Covfefe1nAA6SymbolOSSF":{"name":"n(_:)","abstract":"<p>Creates a new non-terminal symbol</p>"},"Functions.html#/s:7Covfefe2rtAA6SymbolOSSKF":{"name":"rt(_:)","abstract":"<p>Creates a new regular terminal symbol</p>"},"Functions/==(_:_:).html":{"name":"==(_:_:)","abstract":"<p>Determines if two syntax trees are equal to each other.</p>"},"Extensions/String.html#/s:SS7CovfefeE7matchesSays5RangeVySS5IndexVGGSS3for_tKF":{"name":"matches(for:)","abstract":"<p>Returns the ranges of all matches of a regular expression which is provided as the pattern argument</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE7matchesSays5RangeVySS5IndexVGGSS3for_AG2intKF":{"name":"matches(for:in:)","abstract":"<p>Returns the ranges of all matches of a regular expression which is provided as the pattern argument</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE16hasRegularPrefixSbSSKF":{"name":"hasRegularPrefix(_:)","abstract":"<p>Returns a boolean value indicating that the string has a prefix which can be matched by the given regular expression</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE16hasRegularPrefixSbSS_SS5IndexV4fromtKF":{"name":"hasRegularPrefix(_:from:)","abstract":"<p>Returns a boolean value indicating that the string has a prefix beginning at the given start index","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE20rangeOfRegularPrefixs5RangeVySS5IndexVGSgSSKF":{"name":"rangeOfRegularPrefix(_:)","abstract":"<p>Returns the range of a match for the given regular expression beginning at the start of the string</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE20rangeOfRegularPrefixs5RangeVySS5IndexVGSgSS_AF4fromtKF":{"name":"rangeOfRegularPrefix(_:from:)","abstract":"<p>Returns the range of a match for the given regular expression beginning at the start of the string</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE16hasRegularSuffixSbSSKF":{"name":"hasRegularSuffix(_:)","abstract":"<p>Returns a boolean value indicating that the string ends with a substring matched by the given regular expression</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE20rangeOfRegularSuffixs5RangeVySS5IndexVGSgSSKF":{"name":"rangeOfRegularSuffix(_:)","abstract":"<p>Returns the range of a substring matched by the given regular expression ending at the end index of the string</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE9hasPrefixSbSayAA8TerminalVGF":{"name":"hasPrefix(_:)","abstract":"<p>Returns a boolean value indicating that the string has a prefix described by the given sequence of terminal symbols.</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE9hasPrefixSbSayAA8TerminalVG_SS5IndexV4fromtF":{"name":"hasPrefix(_:from:)","abstract":"<p>Returns a boolean value indicating that the string has a prefix from the given start index described by the given","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE13rangeOfPrefixs5RangeVySS5IndexVGSgSayAA8TerminalVGF":{"name":"rangeOfPrefix(_:)","abstract":"<p>Returns the range of the prefix described by the given sequence of terminal symbols</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE13rangeOfPrefixs5RangeVySS5IndexVGSgSayAA8TerminalVG_AF4fromtF":{"name":"rangeOfPrefix(_:from:)","abstract":"<p>Returns the range of the prefix described by the given sequence of terminal symbols","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE9hasSuffixSbSayAA8TerminalVGF":{"name":"hasSuffix(_:)","abstract":"<p>Returns a boolean value indicating that the string has a suffix described by the given sequence of terminal symbols</p>","parent_name":"String"},"Extensions/String.html#/s:SS7CovfefeE13rangeOfSuffixs5RangeVySS5IndexVGSgSayAA8TerminalVGF":{"name":"rangeOfSuffix(_:)","abstract":"<p>Returns the range of the suffix described by the given sequence of terminal symbols</p>","parent_name":"String"},"Extensions/String.html":{"name":"String"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO4leafACyxq_Gq_cAEmr0_lF":{"name":"leaf","abstract":"<p>A leaf storing a leaf element</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO4nodeACyxq_Gx3key_SayAEG8childrentcAEmr0_lF":{"name":"node","abstract":"<p>A node with a key and an arbitrary list of elements</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO3mapACyqd__q_Gqd__xKcKlF":{"name":"map(_:)","abstract":"<p>Generates a new syntax tree by applying the transform function to every key of the tree</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO8mapLeafsACyxqd__Gqd__q_KcKlF":{"name":"mapLeafs(_:)","abstract":"<p>Generates a new syntax tree by applying the transform function to every leaf of the tree</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO5leafsSayq_Gv":{"name":"leafs","abstract":"<p>All leafs of the tree</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO6filterACyxq_GSgSbxKcKF":{"name":"filter(_:)","abstract":"<p>Filters the tree by removing all nodes and their corresponding subtrees if the given predicate is false</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO7explodeSayACyxq_GGSbxKcKF":{"name":"explode(_:)","abstract":"<p>Explodes nodes and passes all child nodes to the parent node if the given closure returns true</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO10compressedACyxq_GyF":{"name":"compressed()","abstract":"<p>Compresses the tree by exploding nodes which have exactly one child node</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO8allNodesSayACyxq_GGSbxKc5where_tKF":{"name":"allNodes(where:)","abstract":"<p>Returns all nodes which match the given predicate.</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:s28CustomDebugStringConvertibleP16debugDescriptionSSv":{"name":"debugDescription","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeOACyxq_Gx3key_SayADG8childrentcfc":{"name":"init(key:children:)","abstract":"<p>Creates a new syntax tree node with a given key and a list of children</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeOACyxq_Gx3key_tcfc":{"name":"init(key:)","abstract":"<p>Creates a new syntax tree with a given root key and no children</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeOACyxq_Gq_5value_tcfc":{"name":"init(value:)","abstract":"<p>Creates a new syntax tree with a given leaf value</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeOAAytRs_r0_lEACyxytGycfc":{"name":"init()","abstract":"<p>Creates an empty tree</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO4rootxSgv":{"name":"root","abstract":"<p>Returns the root key of the tree or nil if no root key exists</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO4leafq_Sgv":{"name":"leaf","abstract":"<p>Returns the value stored in the current node if the current node is a leaf. Otherwise, nil is returned</p>","parent_name":"SyntaxTree"},"Enums/SyntaxTree.html#/s:7Covfefe10SyntaxTreeO8childrenSayACyxq_GGSgv":{"name":"children","abstract":"<p>Returns the direct children of the root node</p>","parent_name":"SyntaxTree"},"Enums/Symbol.html#/s:7Covfefe6SymbolO8terminalAcA8TerminalVcACmF":{"name":"terminal","abstract":"<p>A terminal symbol</p>","parent_name":"Symbol"},"Enums/Symbol.html#/s:7Covfefe6SymbolO11nonTerminalAcA03NonD0VcACmF":{"name":"nonTerminal","abstract":"<p>A non-terminal symbol</p>","parent_name":"Symbol"},"Enums/Symbol.html#/s:s9DecodablePxs7Decoder_p4from_tKcfc":{"name":"init(from:)","parent_name":"Symbol"},"Enums/Symbol.html#/s:s9EncodableP6encodeys7Encoder_p2to_tKF":{"name":"encode(to:)","parent_name":"Symbol"},"Enums/Symbol.html#/s:s8HashableP9hashValueSiv":{"name":"hashValue","parent_name":"Symbol"},"Enums/Symbol.html#/s:s9EquatableP2eeoiSbx_xtFZ":{"name":"==(_:_:)","parent_name":"Symbol"},"Enums/Symbol.html#/s:s23CustomStringConvertibleP11descriptionSSv":{"name":"description","parent_name":"Symbol"},"Enums/Symbol.html":{"name":"Symbol","abstract":"<p>A symbol which can either be a terminal or a non-terminal character</p>"},"Enums/SyntaxTree.html":{"name":"SyntaxTree","abstract":"<p>A tree which can store different types of values in its leafs</p>"},"Enums.html":{"name":"Enums","abstract":"<p>The following enums are available globally.</p>"},"Extensions.html":{"name":"Extensions","abstract":"<p>The following extensions are available globally.</p>"},"Functions.html":{"name":"Functions","abstract":"<p>The following functions are available globally.</p>"},"Protocols.html":{"name":"Protocols","abstract":"<p>The following protocols are available globally.</p>"},"Structs.html":{"name":"Structs","abstract":"<p>The following structs are available globally.</p>"}}
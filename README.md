# NoContext 

NoContext is a parser for languages generated by context free grammars written in Swift.

For a given set of productions (in Chomsky normal form) the parser is able to 
produce a syntax tree for a word contained in the language
or to pinpoint syntax errors, if the word is not contained in the language.

## Example

The following code creates a grammar which can be used to parse arithmetic expressions.
`n(...)` creates a non terminal character, `t(...)` creates a terminal character.

```swift
let S = "S" --> (n("X") <+> n("U")) <|> (n("S") <+> n("V")) <|> (n("Neg") <+> n("S")) <|> SymbolSet.letters <|> (n("VarStart") <+> n("Var"))
let X = "X" --> t("(")
let Y = "Y" --> t(")")
let V = "V" --> n("Op") <+> n("S")
let U = "U" --> n("S") <+> n("Y")
let Op = "Op" --> t("+") <|> t("-") <|> t("*") <|> t("/")
let Neg = "Neg" --> t("-")
let VarStart = "VarStart" --> SymbolSet.letters <|> (n("VarStart") <+> n("Var"))
let Var = "Var" --> SymbolSet.alphanumerics <|> (n("Var") <+> n("Var"))

let grammar = Grammar(productions: S + Op + VarStart + Var + [X, Y, U, V, Neg], start: "S")
```

This grammar can then be used to check if an arithmetic expression is valid.

In a valid expression, all parentheses are closed again and 
binary operators always have a left side and a right side operand.

 A syntax tree can be generated, which describes the structure of a given word.

 ```swift
 let syntaxTree = try grammar.generateSyntaxTree(for: "(a+b)*(-c)")
 ```

	
